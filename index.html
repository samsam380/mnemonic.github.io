<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="utf-8" />
  <title>Mnemonic → Wallet Tree (REAL)</title>

  <style>
    :root {
      --bg:#0D3643; --surface:#123F4F; --text:#E6F1F3;
      --muted:#9FB7BF; --accent:#F2A65A; --accent-hover:#FFB703;
      --danger:#ff6b6b; --ok:#8ff0a4;
    }
    body {
      margin:0;
      min-height:100vh;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,sans-serif;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:40px 12px;
      box-sizing:border-box;
    }
    .app {
      width:min(560px, 100%);
      background:var(--surface);
      border-radius:18px;
      padding:24px;
      box-shadow:0 20px 50px rgba(0,0,0,.4);
    }
    h2 { text-align:center; margin:0 0 12px; }

    textarea, select, input {
      width:100%;
      background:#0f3240;
      border:none;
      border-radius:10px;
      color:var(--text);
      padding:10px;
      font-family:monospace;
      margin-top:8px;
      box-sizing:border-box;
    }
    textarea { min-height:88px; }

    .step { margin-top:16px; border-top:1px solid rgba(255,255,255,.1); padding-top:12px; }
    .step-title { cursor:pointer; color:var(--muted); user-select:none; }
    .step-title:hover { color:var(--accent-hover); }
    .step-title.disabled { opacity:.55; pointer-events:none; }

    .content {
      display:none;
      margin-top:8px;
      font-family:monospace;
      font-size:13px;
      white-space:pre-wrap;
      word-break:break-all;
    }
    .content.show { display:block; animation:fadeIn .25s ease; }
    @keyframes fadeIn { from{opacity:0; transform:translateY(-4px)} to{opacity:1} }

    .hint { font-size:12px; color:var(--muted); }

    .banner {
      margin:10px 0 12px;
      padding:10px;
      border-radius:12px;
      font-size:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--text);
    }
    .banner.warn {
      background:rgba(255,107,107,.12);
      border-color:rgba(255,107,107,.25);
      color:#ffd1d1;
    }

    .statusLine { font-size:12px; color:var(--muted); white-space:pre-wrap; }
    .statusLine.ok { color:var(--ok); }
    .statusLine.err { color:var(--danger); }
    .bar { height:8px; border-radius:999px; background:rgba(255,255,255,.12); overflow:hidden; margin-top:6px; }
    .bar > div { height:100%; width:0%; background:rgba(242,166,90,.9); transition:width .2s ease; }

    .smallBtn {
      margin-top:10px;
      border:none;
      background:rgba(255,255,255,.08);
      color:var(--text);
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:12px;
    }
    .smallBtn:hover { background:rgba(255,255,255,.12); }

    .row { display:flex; gap:10px; align-items:center; }
    .row > * { flex:1; }
    .checkboxRow { display:flex; gap:10px; align-items:center; margin-top:10px; }
    .checkboxRow label { font-size:12px; color:var(--muted); display:flex; gap:8px; align-items:center; }
    .checkboxRow input { width:auto; margin:0; }
  </style>
</head>

<body>
  <div class="app">
    <h2>Mnemonic → Wallet Tree</h2>

    <div class="banner warn">
      This generates <b>REAL</b> keys/addresses (BIP39/BIP32/BIP44/49/84).<br/>
      Use only with mnemonics you own. Prefer running offline if you paste real funds mnemonics.
    </div>

    <div class="statusLine" id="status">Loading crypto libs…</div>
    <div class="bar"><div id="progress"></div></div>

    <div class="step">
      <div class="step-title">① Paste 24-word mnemonic</div>
      <textarea id="mnemonicInput" placeholder="paste mnemonic here…"></textarea>
      <div class="row">
        <input id="passphraseInput" placeholder="optional BIP39 passphrase (aka 25th word) …" />
      </div>
      <div class="hint">Mnemonic is validated against the official BIP39 English wordlist.</div>
    </div>

    <div class="step">
      <div id="step2" class="step-title disabled" onclick="showSeed()">② Seed (512 bits)</div>
      <div class="content" id="seedOut"></div>
      <div class="hint">BIP39 PBKDF2-HMAC-SHA512 · 2048 rounds · salt = "mnemonic"+passphrase</div>
    </div>

    <div class="step">
      <div id="step3" class="step-title disabled" onclick="showMaster()">③ Master key (BIP32)</div>
      <div class="content" id="masterOut"></div>
      <div class="hint">BIP32 root: xprv/xpub, chain code, master pubkey</div>
    </div>

    <div class="step">
      <div class="step-title">④ Choose derivation path</div>
      <select id="pathSelect">
        <option value="m/84'/0'/0'/0">BIP-84 · Native SegWit (bc1)</option>
        <option value="m/49'/0'/0'/0">BIP-49 · Nested SegWit (3...)</option>
        <option value="m/44'/0'/0'/0">BIP-44 · Legacy (1...)</option>
      </select>

      <div class="checkboxRow">
        <label><input type="checkbox" id="showPriv" /> show private keys (dangerous)</label>
      </div>

      <div class="hint">Children derived as path + "/i" for i=0..4</div>
    </div>

    <div class="step">
      <div id="step5" class="step-title disabled" onclick="showAddresses()">⑤ Derived addresses (REAL)</div>
      <div class="content" id="addrOut"></div>
    </div>

    <button class="smallBtn" onclick="resetAll()">Reset</button>
  </div>

<script type="module">
/* -------------------- IMPORTS (ESM CDN) -------------------- */
import { mnemonicToSeedSync, validateMnemonic } from "https://esm.sh/@scure/bip39@1.4.0";
import { wordlist as english } from "https://esm.sh/@scure/bip39@1.4.0/wordlists/english";
import { HDKey } from "https://esm.sh/@scure/bip32@1.6.0";
import { sha256 } from "https://esm.sh/@noble/hashes@1.4.0/sha256";
import { ripemd160 } from "https://esm.sh/@noble/hashes@1.4.0/ripemd160";
import { base58check } from "https://esm.sh/@scure/base@1.1.7";
import { bech32 } from "https://esm.sh/@scure/base@1.1.7";

/* -------------------- STATE -------------------- */
let seedBytes = null;          // 64 bytes
let root = null;               // HDKey (BIP32 root)

/* -------------------- UI HELPERS -------------------- */
const statusEl = document.getElementById('status');
const progEl = document.getElementById('progress');
const step2El = document.getElementById('step2');
const step3El = document.getElementById('step3');
const step5El = document.getElementById('step5');

function setStatus(msg, kind) {
  statusEl.textContent = msg;
  statusEl.className = 'statusLine' + (kind ? (' ' + kind) : '');
}
function setProg(pct) {
  progEl.style.width = Math.max(0, Math.min(100, pct)) + '%';
}
function enableSteps() {
  step2El.classList.remove('disabled');
  step3El.classList.remove('disabled');
  step5El.classList.remove('disabled');
}
function show(elId, text) {
  const el = document.getElementById(elId);
  el.textContent = text;
  el.classList.add('show');
}
function clearShow(elId) {
  const el = document.getElementById(elId);
  el.textContent = '';
  el.classList.remove('show');
}

function normalizeMnemonic(s) {
  return (s || '').trim().toLowerCase().replace(/\s+/g, ' ');
}
function bytesToHex(b) {
  return Array.from(b).map(x => x.toString(16).padStart(2, '0')).join('');
}
function concatBytes(...arrs) {
  const len = arrs.reduce((sum, a) => sum + a.length, 0);
  const out = new Uint8Array(len);
  let o = 0;
  for (const a of arrs) { out.set(a, o); o += a.length; }
  return out;
}

/* -------------------- BITCOIN UTILS -------------------- */
function hash160(pubkeyBytes) {
  return ripemd160(sha256(pubkeyBytes));
}

function p2pkhAddress(pubkeyBytes) {
  // version 0x00 for mainnet
  const h160 = hash160(pubkeyBytes);
  const payload = concatBytes(new Uint8Array([0x00]), h160);
  return base58check.encode(payload);
}

function p2shP2wpkhAddress(pubkeyBytes) {
  // redeemScript = 0x00 0x14 <hash160(pubkey)>
  const h160 = hash160(pubkeyBytes);
  const redeem = concatBytes(new Uint8Array([0x00, 0x14]), h160);
  const redeemHash = ripemd160(sha256(redeem));
  // version 0x05 for mainnet P2SH
  const payload = concatBytes(new Uint8Array([0x05]), redeemHash);
  return base58check.encode(payload);
}

function p2wpkhBech32Address(pubkeyBytes) {
  const h160 = hash160(pubkeyBytes);
  // bech32 witness v0 => words = [0] + convertbits(program 8->5)
  const words = bech32.toWords(h160);
  words.unshift(0); // witness version 0
  return bech32.encode("bc", words);
}

function addressForPath(path, pubkeyBytes) {
  if (path.startsWith("m/84'")) return p2wpkhBech32Address(pubkeyBytes);
  if (path.startsWith("m/49'")) return p2shP2wpkhAddress(pubkeyBytes);
  return p2pkhAddress(pubkeyBytes); // m/44'
}

/* -------------------- BOOT -------------------- */
(function boot() {
  setProg(100);
  setStatus('Ready. Paste mnemonic and click step ②.', 'ok');
  enableSteps();
})();

/* -------------------- STEP 2: SEED (REAL BIP39) -------------------- */
async function showSeed() {
  try {
    const m = normalizeMnemonic(document.getElementById('mnemonicInput').value);
    const passphrase = (document.getElementById('passphraseInput').value || '');

    if (!m) { alert('Paste a mnemonic first.'); return; }

    setStatus('Validating mnemonic…', '');
    setProg(20);

    if (!validateMnemonic(m, english)) {
      setProg(100);
      setStatus('Invalid mnemonic (fails BIP39 wordlist/checksum).', 'err');
      alert('Invalid mnemonic (fails BIP39 validation). Check spelling and word count.');
      return;
    }

    setStatus('Deriving seed… (BIP39 PBKDF2 2048 rounds)', '');
    setProg(45);

    // Real BIP39 seed derivation
    seedBytes = mnemonicToSeedSync(m, passphrase); // Uint8Array(64)

    setProg(80);
    show('seedOut', bytesToHex(seedBytes));
    clearShow('masterOut');
    clearShow('addrOut');
    root = null;

    setProg(100);
    setStatus('Seed derived. Click step ③.', 'ok');
  } catch (e) {
    setProg(100);
    setStatus('Error deriving seed:\n' + (e?.stack || e?.message || String(e)), 'err');
  }
}

/* -------------------- STEP 3: MASTER (REAL BIP32) -------------------- */
async function showMaster() {
  try {
    if (!seedBytes) { alert('First click ② to derive the seed.'); return; }

    setStatus('Computing BIP32 root…', '');
    setProg(35);

    root = HDKey.fromMasterSeed(seedBytes);

    setProg(85);

    const info =
      'BIP32 root (mainnet)\n\n' +
      'xprv:\n' + (root.privateExtendedKey || '(no xprv)') + '\n\n' +
      'xpub:\n' + (root.publicExtendedKey || '(no xpub)') + '\n\n' +
      'Master private key (hex):\n' + (root.privateKey ? bytesToHex(root.privateKey) : '(none)') + '\n\n' +
      'Chain code (hex):\n' + (root.chainCode ? bytesToHex(root.chainCode) : '(none)') + '\n\n' +
      'Master public key (compressed hex):\n' + (root.publicKey ? bytesToHex(root.publicKey) : '(none)');

    show('masterOut', info);

    setProg(100);
    setStatus('Master ready. Click step ⑤ to derive addresses.', 'ok');
  } catch (e) {
    setProg(100);
    setStatus('Error computing master:\n' + (e?.stack || e?.message || String(e)), 'err');
  }
}

/* -------------------- STEP 5: REAL DERIVATION + REAL ADDRESSES -------------------- */
async function showAddresses() {
  try {
    if (!root) { alert('First click ③.'); return; }

    const basePath = document.getElementById('pathSelect').value;
    const showPriv = document.getElementById('showPriv').checked;

    setStatus('Deriving 5 children + encoding addresses…', '');
    setProg(30);

    const out = [];
    for (let i = 0; i < 5; i++) {
      const fullPath = `${basePath}/${i}`; // derive children under change=0
      const child = root.derive(fullPath);

      if (!child.publicKey) throw new Error('Derived key missing publicKey at ' + fullPath);

      const addr = addressForPath(basePath, child.publicKey);

      out.push(
        `Path: ${fullPath}\n` +
        (showPriv ? `Private key (hex): ${child.privateKey ? bytesToHex(child.privateKey) : '(none)'}\n` : '') +
        `Public key (compressed hex): ${bytesToHex(child.publicKey)}\n` +
        `Address: ${addr}\n`
      );

      setProg(30 + Math.round(((i + 1) / 5) * 60));
    }

    show('addrOut',
      out.join('\n') +
      '\n\nNOTE: These are REAL derived outputs. Treat mnemonics/private keys as extremely sensitive.'
    );

    setProg(100);
    setStatus('Done (real derivation).', 'ok');
  } catch (e) {
    setProg(100);
    setStatus('Error deriving addresses:\n' + (e?.stack || e?.message || String(e)), 'err');
  }
}

/* -------------------- RESET -------------------- */
function resetAll() {
  seedBytes = null;
  root = null;
  document.getElementById('mnemonicInput').value = '';
  document.getElementById('passphraseInput').value = '';
  document.getElementById('showPriv').checked = false;
  clearShow('seedOut');
  clearShow('masterOut');
  clearShow('addrOut');
  setProg(100);
  setStatus('Ready. Paste mnemonic and click step ②.', 'ok');
}

/* Expose for inline onclick */
window.showSeed = showSeed;
window.showMaster = showMaster;
window.showAddresses = showAddresses;
window.resetAll = resetAll;
</script>
</body>
</html>
